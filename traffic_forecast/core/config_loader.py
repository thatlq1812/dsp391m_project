"""Config helpers shared across training and dashboard tooling."""

from __future__ import annotations

import json
import os
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Dict, Optional

PROJECT_ROOT = Path(__file__).resolve().parents[2]
DATA_ROOT_ENV_VAR = "STMGT_DATA_ROOT"
DEFAULT_DATA_ROOT = PROJECT_ROOT / "data" / "processed"


@dataclass
class ModelConfig:
    """Hyperparameters controlling the STMGT architecture layout."""

    seq_len: int = 12
    pred_len: int = 12
    hidden_dim: int = 64
    num_heads: int = 4
    num_blocks: int = 2
    mixture_components: int = 3
    num_nodes: Optional[int] = None


@dataclass
class TrainingConfig:
    """Training hyperparameters and data source metadata."""

    batch_size: int = 32
    learning_rate: float = 1e-3
    weight_decay: float = 1e-4
    max_epochs: int = 100
    patience: int = 20
    drop_edge_p: float = 0.2
    num_workers: int = -1
    use_amp: bool = True
    accumulation_steps: int = 1
    data_source: str = "all_runs_extreme_augmented.parquet"
    pin_memory: bool = True
    persistent_workers: bool = True
    prefetch_factor: Optional[int] = 2
    matmul_precision: str = "medium"
    mse_loss_weight: float = 0.0
    use_lr_scheduler: bool = False
    scheduler_type: str = "plateau"
    scheduler_params: dict = field(default_factory=dict)

    def resolve_data_path(self, base_dir: Optional[Path] = None, *, strict: bool = True) -> Path:
        """Return the parquet path for ``data_source`` relative to the data root."""

        root = base_dir or get_data_root()
        candidate = Path(self.data_source)
        if not candidate.suffix:
            candidate = candidate.with_suffix(".parquet")
        if not candidate.is_absolute():
            candidate = (root / candidate).resolve()
        if strict and not candidate.exists():
            raise FileNotFoundError(f"Processed dataset not found at {candidate}")
        return candidate

    def normalised_data_source(self) -> str:
        """Return a normalised dataset identifier for logging purposes."""

        return Path(self.data_source).with_suffix(".parquet").name


@dataclass
class RunConfig:
    """Container holding model, training, and metadata sections."""

    model: ModelConfig = field(default_factory=ModelConfig)
    training: TrainingConfig = field(default_factory=TrainingConfig)
    metadata: Dict[str, str] = field(default_factory=dict)

    @classmethod
    def from_json(cls, path: Path) -> "RunConfig":
        payload = json.loads(path.read_text(encoding="utf-8"))
        model_cfg = ModelConfig(**payload.get("model", {}))
        training_cfg = TrainingConfig(**payload.get("training", {}))
        metadata = payload.get("metadata", {})
        metadata["source_config"] = str(path)
        return cls(model=model_cfg, training=training_cfg, metadata=metadata)

    def to_dict(self) -> Dict[str, Dict[str, object]]:
        return {
            "model": {key: getattr(self.model, key) for key in vars(self.model)},
            "training": {key: getattr(self.training, key) for key in vars(self.training)},
            "metadata": self.metadata,
        }


def load_run_config(config_path: Optional[Path]) -> RunConfig:
    """Load a run configuration generated by the dashboard or use defaults."""

    if config_path is not None and config_path.exists():
        run_config = RunConfig.from_json(config_path)
    else:
        run_config = RunConfig()
        if config_path is not None:
            print(f"WARNING: Config not found at {config_path}, using defaults")

    run_config.metadata.setdefault("launched_at", datetime.utcnow().isoformat())
    return run_config


def get_data_root() -> Path:
    """Return the processed data directory honouring environment overrides."""

    override = os.environ.get(DATA_ROOT_ENV_VAR)
    if override:
        candidate = Path(override).expanduser()
        if not candidate.is_absolute():
            candidate = (PROJECT_ROOT / candidate).resolve()
        return candidate
    return DEFAULT_DATA_ROOT
